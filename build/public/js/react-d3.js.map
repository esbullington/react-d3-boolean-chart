{"version":3,"names":[],"mappings":"","sources":["react-d3.js"],"sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.rd3 = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nexports.BooleanChart = require('./booleanchart').BooleanChart;\n\n\n\n},{\"./booleanchart\":4}],2:[function(require,module,exports){\n'use strict';\n\nvar React = (window.React);\nvar d3 = (window.d3);\nvar common = require('../common');\nvar Chart = common.Chart;\nvar XAxis = common.XAxis;\nvar YAxis = common.YAxis;\nvar utils = require('../utils');\nvar StackedChart = require('./StackedChart');\nvar mixins = require('../mixins');\nvar CartesianChartPropsMixin = mixins.CartesianChartPropsMixin;\n\n\nmodule.exports = React.createClass({\n\n  displayName: 'BooleanChart',\n\n  mixins: [ CartesianChartPropsMixin ],\n\n  propTypes: {\n    margins: React.PropTypes.object,\n    stackedChartMargins: React.PropTypes.object,\n    colors: React.PropTypes.func,\n    displayDataPoints: React.PropTypes.bool,\n    booleanLabels: React.PropTypes.object,\n    stackedChartLabel: React.PropTypes.bool\n  },\n\n  getDefaultProps:function() {\n    return {\n      stackedChartHeight: 120,\n      margins: {top: 10, right: 20, bottom: 40, left: 45},\n      stackedChartMargins: {top: 20, right: 20, bottom: 20, left: 45},\n      className: 'rd3-booleanchart',\n      stackedChartLabel: false,\n      booleanLabels: {on: 'on', off: 'off'}\n    };\n  },\n\n  render:function() {\n\n    var props = this.props;\n\n    if (!Array.isArray(props.data)) {\n      props.data = [props.data];\n    }\n\n    var numberItems = props.data.length;\n\n    var chartHeight = props.height / numberItems;\n\n    // Calculate inner stacked chart dimensions\n    var innerWidth, innerHeight;\n    innerWidth = props.width - props.margins.left - props.margins.right;\n    innerHeight = props.height - props.margins.top - props.margins.bottom;\n\n    var stackedChartInnerHeight;\n    stackedChartInnerHeight = props.stackedChartHeight - props.stackedChartMargins.top - props.stackedChartMargins.bottom;\n\n    if (props.legend) {\n      innerWidth = innerWidth - props.legendOffset;\n    }\n\n    var flattenedData = utils.flattenData(props.data, props.xAccessor, props.yAccessor);\n\n    var allValues = flattenedData.allValues,\n        xValues = flattenedData.xValues,\n        yValues = flattenedData.yValues;\n\n    var scales = utils.calculateScales(innerWidth, innerHeight, xValues, yValues);\n\n    var trans = (\"translate(\" +  props.margins.left + \",\" +  props.stackedChartMargins.top + \")\");\n\n    var yScale = d3.scale.ordinal()\n      .domain([true, false])\n      .rangeBands([0, props.stackedChartInnerHeight/2]);\n\n    var charts = props.data.map( function(series, idx)  {\n          return (\n            React.createElement(\"svg\", {\n              key: idx, \n              y: idx * (props.stackedChartHeight), \n              width: props.width, \n              height:  props.stackedChartInnerHeight\n            }, \n              React.createElement(\"g\", {transform: trans, className: props.className}, \n               \n                // If it's the last series, we display the x axis\n                // otherwise, it's a dotted line\n                idx === props.data.length - 1 ? React.createElement(XAxis, {\n                  xAxisClassName: \"rd3-linechart-xaxis\", \n                  tickFormatting: props.xAxisFormatter, \n                  xAxisLabel: props.xAxisLabel, \n                  xAxisLabelOffset: props.xAxisLabelOffset, \n                  xAxisTickCount: props.xAxisTickCount, \n                  xOrient: props.xOrient, \n                  xScale: scales.xScale, \n                  width: innerWidth, \n                  height: stackedChartInnerHeight, \n                  stroke: props.axesColor, \n                  strokeWidth: props.strokeWidth})\n                : React.createElement(\"line\", {\n                    strokeWidth: \"1\", \n                    stroke: \"black\", \n                    strokeDasharray: \"5, 4\", \n                    x1: \"0\", y1: stackedChartInnerHeight, x2: innerWidth, y2: stackedChartInnerHeight}), \n              \n                React.createElement(StackedChart, {\n                  xScale: scales.xScale, \n                  yScale: yScale, \n                  seriesName: series.name, \n                  data: series.values, \n                  fill: props.colors(idx), \n                  key: series.name, \n                  xAccessor: props.xAccessor, \n                  yAccessor: props.yAccessor, \n                  booleanLabels: series.booleanLabels ? series.yAxisLabels : props.booleanLabels, \n                  stackedChartIndex: idx, \n                  stackedChartTop: idx * (stackedChartInnerHeight), \n                  stackedChartHeight: stackedChartInnerHeight, \n                  stackedChartLabel: props.stackedChartLabel}\n                )\n              )\n            )\n        )\n    });\n    return React.createElement(Chart, {\n            viewBox: props.viewBox, \n            legend: props.legend, \n            data: props.data, \n            margins: props.margins, \n            colors: props.colors, \n            width: props.width, \n            height: props.height, \n            title: props.title\n          }, \n          charts, \n          React.createElement(\"text\", {\n            strokeWidth: \"0.01\", \n            y: 10, x: -props.height/2, \n            textAnchor: \"middle\", \n            transform: \"rotate(270)\"}, \n            props.yAxisLabel\n          )\n          );\n\n  }\n\n});\n\n\n\n},{\"../common\":16,\"../mixins\":18,\"../utils\":19,\"./StackedChart\":3}],3:[function(require,module,exports){\n'use strict';\n\nvar React = (window.React);\nvar d3 = (window.d3);\n\nmodule.exports = React.createClass({\n\n  displayName: 'StackedChart',\n\n  propTypes: {\n    data: React.PropTypes.array,\n    interpolationType: React.PropTypes.string,\n    fill: React.PropTypes.string,\n    xAccessor: React.PropTypes.func,\n    yAccessor: React.PropTypes.func,\n    displayDataPoints: React.PropTypes.bool,\n    booleanLabels: React.PropTypes.object,\n    stackedChartLabel: React.PropTypes.bool\n  },\n\n  getDefaultProps:function() {\n    return {\n      data: [],\n      interpolationType: 'linear',\n      fill: '#fff',\n      xAccessor: function(d)  {return d.x;},\n      yAccessor: function(d)  {return d.y;},\n      displayDataPoints: true,\n      squareWaveOffsetDivisor: 4,\n    };\n  },\n\n  _isDate:function(d, accessor) {\n    return Object.prototype.toString.call(accessor(d)) === '[object Date]';\n  },\n\n  renderVertical:function(isNotSameValue, linePoints) {\n    if (isNotSameValue) {\n      return React.createElement(\"line\", {\n        stroke: this.props.fill, \n        strokeWidth: \"2\", \n        x1: linePoints.x1, \n        x2: linePoints.x2, \n        y1: linePoints.y1, \n        y2: linePoints.y2}\n        );\n    }\n    return React.createElement(\"g\", null);\n  },\n\n  render:function() {\n\n    var props = this.props;\n\n    var xAccessor = props.xAccessor,\n        yAccessor = props.yAccessor;\n\n    var yScale = d3.scale.ordinal()\n      .domain([true, false])\n      .rangeBands([0, props.stackedChartHeight/2]);\n\n    // Create array of paths, which we'll map over\n    // to generate SVG lines\n    var interpolatePath = d3.svg.line()\n        .y(function(d) {\n          return props.yScale(props.yAccessor(d));\n        })\n        .interpolate(props.interpolationType);\n\n    // Check whether or not an arbitrary data element\n    // is a date object (at index 0 here)\n    // If it's a date, then we set the x scale a bit differently\n    if (this._isDate(props.data[0], xAccessor)) {\n        interpolatePath.x(function(d) {\n          return props.xScale(props.xAccessor(d).getTime());\n        });\n    } else {\n        interpolatePath.x(function(d) {\n          return props.xScale(props.xAccessor(d));\n        });\n    }\n\n    var lines = props.data.map(function(point, i) {\n      var x1, x2, y1, y2, cy1, cy2, nextPoint, prevPoint;\n\n      if (i === props.data.length - 1) {\n        nextPoint = props.data[i];\n        prevPoint = props.data[i - 1]\n      } else if (i === 0) {\n        nextPoint = props.data[i + 1];\n        prevPoint = point;\n      } else {\n        nextPoint = props.data[i + 1];\n        prevPoint = props.data[i - 1]\n      }\n\n      if (this._isDate(point, xAccessor)) {\n        x1 = props.xScale(xAccessor(point).getTime());\n        x2 = props.xScale(xAccessor(nextPoint).getTime());\n      } else {\n        x1 = props.xScale(xAccessor(point));\n        x2 = props.xScale(xAccessor(nextPoint));\n      }\n\n      var squareWaveOffset = props.stackedChartHeight/props.squareWaveOffsetDivisor;\n\n      if (yAccessor(point)) {\n        y1 = squareWaveOffset;\n        y2 = squareWaveOffset;\n      } else {\n        y1 = props.stackedChartHeight - squareWaveOffset;\n        y2 = props.stackedChartHeight - squareWaveOffset;\n      }\n\n      var prevy2, prevy1;\n      if (yAccessor(prevPoint)) {\n        prevy1 = squareWaveOffset;\n        prevy2 = squareWaveOffset;\n      } else {\n        prevy1 = props.stackedChartHeight - squareWaveOffset;\n        prevy2 = props.stackedChartHeight - squareWaveOffset;\n      }\n \n      var isNotSameValue = yAccessor(point) !== yAccessor(nextPoint);\n\n      var linePoints = {\n        x1: x2,\n        x2: x2,\n        // y1 and y1 are always equal to the difference between \n        // the height of the stacked chart less the squareWaveOffset\n        // and the squareWaveOffset itself\n        y1: props.stackedChartHeight - squareWaveOffset,\n        y2: squareWaveOffset\n      };\n\n      return (\n        React.createElement(\"g\", {key: i}, \n        React.createElement(\"line\", {\n          stroke: props.fill, \n          strokeWidth: \"2\", \n          key: i, \n          x1: x1, \n          y1: y1, \n          x2: x2, \n          y2: y2}\n        ), \n        isNotSameValue ? React.createElement(\"line\", {\n          stroke: props.fill, \n          strokeWidth: \"2\", \n          x1: linePoints.x1, \n          x2: linePoints.x2, \n          y1: linePoints.y1, \n          y2: linePoints.y2}\n          ) : React.createElement(\"g\", null)\n        \n        )\n      );\n    }, this);\n\n    return (\n      React.createElement(\"g\", null, \n         props.stackedChartLabel ? \n          React.createElement(\"text\", {\n          fontSize: \"120%\"\n          }, props.seriesName)\n        : React.createElement(\"text\", null), \n        \n        lines, \n        React.createElement(\"text\", {\n          strokeWidth: \"0.01\", \n          textAnchor: \"middle\", \n          dy: \"0.25em\", \n          x: -25, \n          y: props.stackedChartHeight - (props.stackedChartHeight/props.squareWaveOffsetDivisor)\n        }, props.booleanLabels.off), \n        React.createElement(\"text\", {\n          dy: \"0.25em\", \n          strokeWidth: \"0.01\", \n          textAnchor: \"middle\", \n          x: -25, \n          y: props.stackedChartHeight/props.squareWaveOffsetDivisor\n        }, props.booleanLabels.on)\n      )\n    );\n  }\n\n});\n\n\n\n},{}],4:[function(require,module,exports){\nexports.BooleanChart = require('./BooleanChart');\n\n\n\n},{\"./BooleanChart\":2}],5:[function(require,module,exports){\n'use strict';\n\nvar React = (window.React);\nvar d3 = (window.d3);\n\nmodule.exports = React.createClass({displayName: \"exports\",\n\n  propTypes: {\n    width: React.PropTypes.number,\n    height: React.PropTypes.number,\n    margins: React.PropTypes.object,\n    text: React.PropTypes.string,\n    colors: React.PropTypes.func\n  },\n\n  getDefaultProps: function() {\n    return {\n      text: \"#000\",\n      colors: d3.scale.category20c()\n    };\n  },\n\n  render: function() {\n\n    var props = this.props;\n\n    var textStyle = {\n      'color': 'black',\n      'fontSize': '50%',\n      'verticalAlign': 'top'\n    };\n\n    var legendItems = [];\n\n    props.data.forEach( function(series, idx)  {\n\n      var itemStyle = {\n        'color': props.colors(idx),\n        'lineHeight': '60%',\n        'fontSize': '200%'\n      };\n\n      legendItems.push(\n            React.createElement(\"li\", {style: itemStyle, key: idx}, \n              React.createElement(\"span\", {style: textStyle}, series.name)\n            )\n          );\n\n    });\n\n    // In preparation for legend positioning\n    var legendFloat = 'right';\n\n    var topMargin = props.margins.top;\n\n    var legendBlockStyle = {\n      'wordWrap': 'break-word',\n      'width': props.sideOffset,\n      'paddingLeft': '0',\n      'marginBottom': '0',\n      'marginTop': topMargin,\n      'float': legendFloat\n    };\n\n    return React.createElement(\"ul\", {style: legendBlockStyle}, legendItems);\n  }\n\n});\n\n\n\n\n},{}],6:[function(require,module,exports){\n'use strict';\n\nvar React = (window.React);\nvar d3 = (window.d3);\n\nmodule.exports = React.createClass({displayName: \"exports\",\n\n  propTypes: {\n    scale: React.PropTypes.func.isRequired,\n    innerTickSize: React.PropTypes.number,\n    outerTickSize: React.PropTypes.number,\n    tickPadding: React.PropTypes.number,\n    tickArguments: React.PropTypes.array,\n    fill: React.PropTypes.string,\n    stroke: React.PropTypes.string\n  },\n\n  getDefaultProps:function() {\n    return {\n      innerTickSize: 6,\n      outerTickSize: 6,\n      tickPadding: 3,\n      tickArguments: [10],\n      tickValues: null,\n      tickFormat: null \n    };\n  },\n\n\n  _d3_scaleExtent:function(domain) {\n    var start = domain[0], stop = domain[domain.length - 1];\n    return start < stop ? [start, stop] : [stop, start];\n  },\n\n  _d3_scaleRange:function(scale) {\n    return scale.rangeExtent ? scale.rangeExtent() : this._d3_scaleExtent(scale.range());\n  },\n\n  render:function() {\n\n    var props = this.props;\n    var sign = props.orient === \"top\" || props.orient === \"left\" ? -1 : 1;\n\n    var range = this._d3_scaleRange(props.scale);\n\n    var d;\n\n    if (props.orient === \"bottom\" || props.orient === \"top\") {\n      d = \"M\" + range[0] + \",\" + sign * props.outerTickSize + \"V0H\" + range[1] + \"V\" + sign * props.outerTickSize;\n    } else {\n      d = \"M\" + sign * props.outerTickSize + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + sign * props.outerTickSize;\n    }\n\n\n    return (\n      React.createElement(\"path\", {\n        className: \"domain\", \n        d: d, \n        style: {'shapeRendering':'crispEdges'}, \n        fill: \"none\", \n        stroke: props.stroke, \n        strokeWidth: props.strokeWidth\n      }\n      )\n    );\n  }\n});\n\n\n\n},{}],7:[function(require,module,exports){\n'use strict';\n\nvar React = (window.React);\nvar d3 = (window.d3);\n\nmodule.exports = React.createClass({displayName: \"exports\",\n  getDefaultProps:function() {\n    return {\n      innerTickSize: 6,\n      outerTickSize: 6,\n      tickPadding: 3,\n      tickArguments: [10],\n      tickValues: null\n    };\n  },\n\n  render:function() {\n    var props = this.props;\n\n    var tr,\n        ticks,\n        scale,\n        adjustedScale,\n        textAnchor,\n        tickFormat,\n        y1, y2, dy, x1, x2, dx;\n\n    var sign = props.yScale ? -1 : 1;\n    var tickSpacing = Math.max(props.innerTickSize, 0) + props.tickPadding;  \n\n    scale = props.yScale ? props.yScale : props.xScale;\n\n    ticks = props.tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, props.tickArguments) : scale.domain()) : props.tickValues;\n    if (props.tickFormatting) {\n        tickFormat = props.tickFormatting\n    } else if (scale.tickFormat) {\n        tickFormat = scale.tickFormat.apply(scale, props.tickArguments)\n    } else {\n        tickFormat = function(d) {return d;};\n\n    }\n\n    adjustedScale = scale.rangeBand ? function(d)  { return scale(d) + scale.rangeBand() / 2; } : scale;\n\n    // Still working on this\n    // Ticks and lines are not fully aligned\n    // in some orientations\n    switch (props.orient) {\n      case 'top':\n        tr = function(tick)  {return (\"translate(\" + adjustedScale(tick) + \",0)\");};\n        textAnchor = \"middle\";\n        y2 = props.innerTickSize * sign;\n        y1 = tickSpacing * sign;\n        dy =  sign < 0 ? \"0em\" : \".71em\";\n        break;\n      case 'bottom':\n        tr = function(tick)  {return (\"translate(\" + adjustedScale(tick) + \",0)\");};\n        textAnchor = \"middle\";\n        y2 = props.innerTickSize * sign;\n        y1 = tickSpacing * sign;\n        dy =  sign < 0 ? \"0em\" : \".71em\";\n        break;\n      case 'left':\n        tr = function(tick)  {return (\"translate(0,\" + adjustedScale(tick) + \")\");};\n        textAnchor = \"end\";\n        x2 = props.innerTickSize * sign;\n        x1 = tickSpacing * sign;\n        dy = \".32em\";\n        break;\n      case 'right':\n        tr = function(tick)  {return (\"translate(0,\" + adjustedScale(tick) + \")\");};\n        textAnchor = \"end\";\n        x2 = props.innerTickSize;\n        x1 = tickSpacing * sign;\n        dy = \".32em\";\n        break;\n    }\n\n    return (\n      React.createElement(\"g\", null, \n        ticks.map( function(tick, i)  {\n          return (\n            React.createElement(\"g\", {key: i, className: \"tick\", transform: tr(tick)}, \n              React.createElement(\"line\", {style: {shapeRendering:'crispEdges',opacity:'1',stroke:'#000'}, x2: x2, y2: y2}\n              ), \n              React.createElement(\"text\", {\n                strokeWidth: \"0.01\", \n                dy: dy, x: x1, y: y1, \n                stroke: \"#000\", \n                textAnchor: textAnchor\n              }, \n                tickFormat(tick)\n              )\n            )\n          );\n          })\n        \n      )\n    );\n  }\n\n});\n\n\n\n},{}],8:[function(require,module,exports){\n'use strict';\n\nvar React = (window.React);\n\n\nmodule.exports = React.createClass({displayName: \"exports\",\n\n  render:function() {\n    var props = this.props;\n    var strokeWidth = '0.01';\n    if (props.label) {\n      switch (props.orient) {\n        case 'top':\n          return (\n            React.createElement(\"text\", {\n              strokeWidth: strokeWidth, \n              y: props.offset, x: props.width/2, \n              textAnchor: \"middle\"}, \n              props.label\n            )\n          );\n        case 'bottom':\n          return (\n            React.createElement(\"text\", {\n              strokeWidth: strokeWidth, \n              y: props.offset, x: props.width/2, \n              textAnchor: \"middle\"}, \n              props.label\n            )\n          );\n        case 'left':\n          return (\n            React.createElement(\"text\", {\n              strokeWidth: strokeWidth, \n              y: -props.offset, x: -props.height/2, \n              textAnchor: \"middle\", \n              transform: \"rotate(270)\"}, \n              props.label\n            )\n          );\n        case 'right':\n          return (\n            React.createElement(\"text\", {\n              strokeWidth: strokeWidth, \n              y: props.offset, x: -props.height/2, \n              textAnchor: \"middle\", \n              transform: \"rotate(270)\"}, \n              props.label\n            )\n          );\n      }\n    }\n    return React.createElement(\"text\", null);\n  }\n\n});\n\n\n\n\n\n},{}],9:[function(require,module,exports){\n'use strict';\n\nvar React = (window.React);\nvar d3 = (window.d3);\nvar AxisTicks = require('./AxisTicks');\nvar AxisLine = require('./AxisLine');\nvar Label = require('./Label');\n\nmodule.exports = React.createClass({displayName: \"exports\",\n\n  propTypes: {\n    xAxisClassName: React.PropTypes.string.isRequired,\n    xOrient: React.PropTypes.oneOf(['top', 'bottom']),\n    xScale: React.PropTypes.func.isRequired,\n    height: React.PropTypes.number.isRequired,\n    fill: React.PropTypes.string,\n    stroke: React.PropTypes.string,\n    tickStroke: React.PropTypes.string,\n    strokeWidth: React.PropTypes.string,\n    xAxisOffset: React.PropTypes.number\n  },\n\n  getDefaultProps:function() {\n    return {\n      xAxisClassName: 'x axis',\n      xAxisLabelOffset: 10,\n      xOrient: 'bottom',\n      fill: 'none',\n      stroke: 'none',\n      tickStroke: '#000',\n      strokeWidth: 'none',\n      xAxisOffset: 0,\n      label: ''\n    };\n  },\n\n  render:function() {\n    var props = this.props;\n\n    var t = (\"translate(0,\" + (props.xAxisOffset + props.height) + \")\");\n\n    var tickArguments;\n    if (typeof props.xAxisTickCount !== 'undefined') {\n      tickArguments = [props.xAxisTickCount];\n    }\n    \n    if (typeof props.xAxisTickInterval !== 'undefined') {\n      tickArguments = [d3.time[props.xAxisTickInterval.unit], props.xAxisTickInterval.interval];\n    }\n\n    return (\n      React.createElement(\"g\", {\n        className: props.xAxisClassName, \n        transform: t\n      }, \n        React.createElement(Label, {\n          label: props.xAxisLabel, \n          offset: props.xAxisLabelOffset, \n          orient: props.xOrient, \n          margins: props.margins, \n          width: props.width}\n        ), \n        React.createElement(AxisTicks, {\n          tickFormatting: props.tickFormatting, \n          tickArguments: tickArguments, \n          xScale: props.xScale, \n          orient: props.xOrient}\n        ), \n        React.createElement(AxisLine, React.__spread({\n          scale: props.xScale, \n          orient: props.xOrient}, \n          props)\n        )\n      )\n    );\n  }\n\n});\n\n\n\n},{\"./AxisLine\":6,\"./AxisTicks\":7,\"./Label\":8}],10:[function(require,module,exports){\n'use strict';\n\nvar React = (window.React);\nvar d3 = (window.d3);\nvar AxisTicks = require('./AxisTicks');\nvar AxisLine = require('./AxisLine');\n\nmodule.exports = React.createClass({displayName: \"exports\",\n\n  propTypes: {\n    yAxisClassName: React.PropTypes.string,\n    yOrient: React.PropTypes.oneOf(['left', 'right']),\n    yScale: React.PropTypes.func.isRequired,\n    fill: React.PropTypes.string,\n    stroke: React.PropTypes.string,\n    tickStroke: React.PropTypes.string,\n    strokeWidth: React.PropTypes.string,\n    yAxisOffset: React.PropTypes.number\n  },\n\n  getDefaultProps:function() {\n    return {\n      yAxisClassName: 'y axis',\n      yOrient: 'left',\n      fill: 'none',\n      stroke: '#000',\n      tickStroke: '#000',\n      strokeWidth: '1',\n      yAxisOffset: 0\n    };\n  },\n\n  render:function() {\n\n    var props = this.props;\n\n    var t;\n    if (props.yOrient === 'right') {\n       t = (\"translate(\" + (props.yAxisOffset + props.width) + \",0)\");\n    } else {\n       t = (\"translate(\" + props.yAxisOffset + \",0)\");\n    }\n\n    var tickArguments;\n    if (props.yAxisTickCount) {\n      tickArguments = [props.yAxisTickCount];\n    }\n    \n    if (props.yAxisTickInterval) {\n      tickArguments = [d3.time[props.yAxisTickInterval.unit], props.yAxisTickInterval.interval];\n    }\n\n    return (\n      React.createElement(\"g\", {\n        className: props.yAxisClassName, \n        transform: t\n      }, \n        React.createElement(AxisTicks, {\n          tickFormatting: props.tickFormatting, \n          tickArguments: tickArguments, \n          yScale: props.yScale, \n          orient: props.yOrient, \n          height: props.height, \n          width: props.width}\n        ), \n        React.createElement(AxisLine, React.__spread({\n          scale: props.yScale, \n          orient: props.yOrient}, \n          props)\n        )\n      )\n    );\n  }\n\n});\n\n\n\n},{\"./AxisLine\":6,\"./AxisTicks\":7}],11:[function(require,module,exports){\n\nexports.XAxis = require('./XAxis');\nexports.YAxis = require('./YAxis');\n\n\n\n},{\"./XAxis\":9,\"./YAxis\":10}],12:[function(require,module,exports){\n'use strict';\n\nvar React = (window.React);\n\nmodule.exports = React.createClass({displayName: \"exports\",\n  render: function() {\n    return (\n      React.createElement(\"div\", null, \n        React.createElement(\"svg\", {\n          viewBox: this.props.viewBox, \n          width: this.props.width, \n          height: this.props.height\n        }, this.props.children)\n      )\n    );\n  }\n});\n\n\n\n},{}],13:[function(require,module,exports){\n'use strict';\n\nvar React = (window.React);\nvar LegendChart = require('./LegendChart');\nvar BasicChart = require('./BasicChart');\n\nmodule.exports = React.createClass({displayName: \"exports\",\n\n  propTypes: {\n    legend: React.PropTypes.bool,\n    viewBox: React.PropTypes.string\n  },\n\n  getDefaultProps: function() {\n    return {\n      legend: false\n    };\n  },\n\n  render: function() {\n    if (this.props.legend) {\n      return React.createElement(LegendChart, React.__spread({},  this.props));\n    }\n    return React.createElement(BasicChart, React.__spread({},  this.props));\n  }\n\n});\n\n\n\n\n},{\"./BasicChart\":12,\"./LegendChart\":14}],14:[function(require,module,exports){\n'use strict';\n\nvar React = (window.React);\nvar Legend = require('../Legend');\n\nmodule.exports = React.createClass({displayName: \"exports\",\n\n  propTypes: {\n    legend: React.PropTypes.bool,\n    legendPosition: React.PropTypes.string,\n    sideOffset: React.PropTypes.number,\n    margins: React.PropTypes.object,\n    data: React.PropTypes.oneOfType([\n      React.PropTypes.object,\n      React.PropTypes.array\n    ])\n  },\n\n  getDefaultProps:function() {\n    return {\n      data: {},\n      legend: false,\n      legendPosition: 'right',\n      sideOffset: 90\n    };\n  },\n\n  _renderLegend:function() {\n    if (this.props.legend) {\n      return (\n        React.createElement(Legend, {\n          legendPosition: this.props.legendPosition, \n          margins: this.props.margins, \n          colors: this.props.colors, \n          data: this.props.data, \n          width: this.props.width, \n          height: this.props.height, \n          sideOffset: this.props.sideOffset}\n        ) \n      );\n    }\n  },\n\n  render:function() {\n    return (\n      React.createElement(\"div\", {style: {'width': this.props.width, 'height': this.props.height}}, \n        React.createElement(\"h4\", null, this.props.title), \n        this._renderLegend(), \n        React.createElement(\"svg\", {viewBox: this.props.viewBox, width: this.props.width - this.props.sideOffset, height: this.props.height}, this.props.children)\n      )\n    );\n  }\n});\n\n\n\n},{\"../Legend\":5}],15:[function(require,module,exports){\n\nexports.BasicChart = require('./BasicChart');\nexports.Chart = require('./Chart');\nexports.LegendChart = require('./LegendChart');\n\n\n\n},{\"./BasicChart\":12,\"./Chart\":13,\"./LegendChart\":14}],16:[function(require,module,exports){\nexports.XAxis = require('./axes').XAxis;\nexports.YAxis = require('./axes').YAxis;\nexports.Chart = require('./charts').Chart;\nexports.LegendChart = require('./charts').LegendChart;\nexports.Legend = require('./Legend');\n\n\n\n},{\"./Legend\":5,\"./axes\":11,\"./charts\":15}],17:[function(require,module,exports){\n'use strict';\n\nvar React = (window.React);\nvar d3 = (window.d3);\n\nmodule.exports =  {\n\n  propTypes: {\n    axesColor: React.PropTypes.string,\n    colors: React.PropTypes.func,\n    data: React.PropTypes.oneOfType([\n      React.PropTypes.array,\n      React.PropTypes.object\n    ]).isRequired,\n    xOrient: React.PropTypes.oneOf(['top', 'bottom']),\n    yOrient: React.PropTypes.oneOf(['left', 'right']),\n    yAxisTickCount: React.PropTypes.number,\n    yAxisLabel: React.PropTypes.string,\n    yAxisLabelOffset: React.PropTypes.number,\n    yAxisFormatter: React.PropTypes.func,\n    xAxisTickInterval: React.PropTypes.object,\n    xAxisLabel: React.PropTypes.string,\n    xAxisLabelOffset: React.PropTypes.number,\n    xAxisFormatter: React.PropTypes.func,\n    legend: React.PropTypes.bool,\n    legendOffset: React.PropTypes.number,\n    width: React.PropTypes.number,\n    height: React.PropTypes.number,\n    xAccessor: React.PropTypes.func,\n    yAccessor: React.PropTypes.func,\n    title: React.PropTypes.string,\n    viewBox: React.PropTypes.string\n  },\n\n  getDefaultProps: function() {\n    return {\n      data: [],\n      xOrient: 'bottom',\n      xAxisLabel: '',\n      xAxisLabelOffset: 38,\n      yOrient: 'left',\n      yAxisLabel: '',\n      yAxisLabelOffset: 35,\n      legend: false,\n      legendOffset: 120,\n      width: 400,\n      height: 200,\n      axesColor: '#000',\n      title: '',\n      colors: d3.scale.category20c(),\n      xAccessor: function(d)  {return d.x;},\n      yAccessor: function(d)  {return d.y;}\n    };\n  }\n\n};\n\n\n\n},{}],18:[function(require,module,exports){\n\nexports.CartesianChartPropsMixin = require('./CartesianChartPropsMixin');\n\n\n\n},{\"./CartesianChartPropsMixin\":17}],19:[function(require,module,exports){\nvar d3 = (window.d3);\n\n\nexports.calculateScales = function(chartWidth, chartHeight, xValues, yValues)  {\n\n  var xScale, yScale;\n\n  if (xValues.length > 0 && Object.prototype.toString.call(xValues[0]) === '[object Date]') {\n    xScale = d3.time.scale()\n      .range([0, chartWidth]);\n  } else {\n    xScale = d3.scale.linear()\n      .range([0, chartWidth]);\n  }\n  xScale.domain(d3.extent(xValues));\n\n  if (yValues.length > 0 && Object.prototype.toString.call(yValues[0]) === '[object Date]') {\n    yScale = d3.time.scale()\n      .range([chartHeight, 0]);\n  } else {\n    yScale = d3.scale.linear()\n      .range([chartHeight, 0]);\n  }\n\n  yScale.domain(d3.extent(yValues));\n\n  return {\n    xScale: xScale,\n    yScale: yScale\n  };\n\n};\n\n// debounce from Underscore.js\n// MIT License: https://raw.githubusercontent.com/jashkenas/underscore/master/LICENSE\n// Copyright (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative\n// Reporters & Editors\nexports.debounce = function(func, wait, immediate) {\n  var timeout;\n  return function() {\n    var context = this, args = arguments;\n    var later = function() {\n      timeout = null;\n      if (!immediate) {\n        func.apply(context, args);\n      }\n    };\n    var callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) func.apply(context, args);\n  };\n};\n\nexports.flattenData = function(data, xAccessor, yAccessor)  {\n\n  var allValues = [];\n  var xValues = [];\n  var yValues = [];\n  var coincidentCoordinateCheck = {};\n\n  data.forEach( function(series)  {\n    series.values.forEach( function(item, idx)  {\n\n      var x = xAccessor(item);\n\n      // Check for NaN since d3's Voronoi cannot handle NaN values\n      // Go ahead and Proceed to next iteration since we don't want NaN\n      // in allValues or in xValues or yValues\n      if (isNaN(x)) {\n        return;\n      }\n      xValues.push(x);\n\n      var y = yAccessor(item);\n      // when yAccessor returns an object (as in the case of candlestick)\n      // iterate over the keys and push all the values to yValues array\n      var yNode;\n      if (typeof y === 'object' && Object.keys(y).length > 0) {\n        Object.keys(y).forEach(function (key) {\n          // Check for NaN since d3's Voronoi cannot handle NaN values\n          // Go ahead and Proceed to next iteration since we don't want NaN\n          // in allValues or in xValues or yValues\n          if (isNaN(y[key])) {\n            return;\n          }\n          yValues.push(y[key]);\n          // if multiple y points are to be plotted for a single x\n          // as in the case of candlestick, default to y value of 0\n          yNode = 0;\n        });\n      } else {\n        // Check for NaN since d3's Voronoi cannot handle NaN values\n        // Go ahead and Proceed to next iteration since we don't want NaN\n        // in allValues or in xValues or yValues\n        if (isNaN(y)) {\n          return;\n        }\n        yValues.push(y);\n        yNode = y;\n      }\n\n      var xyCoords = ( x + \"-\" +  yNode);\n      if (xyCoords in coincidentCoordinateCheck) {\n        // Proceed to next iteration if the x y pair already exists\n        // d3's Voronoi cannot handle NaN values or coincident coords\n        // But we push them into xValues and yValues above because\n        // we still may handle them there (labels, etc.)\n        return;\n      }\n      coincidentCoordinateCheck[xyCoords] = '';\n      var pointItem = {\n        coord: {\n          x: x,\n          y: yNode,\n        },\n        id: ( series.name + \"-\" +  idx)\n      };\n      allValues.push(pointItem);\n    });\n  });\n\n  return {\n    allValues: allValues,\n    xValues: xValues,\n    yValues: yValues\n  };\n};\n\n\nexports.shade = function(hex, percent)  {\n\n  var R, G, B, red, green, blue, number;\n  var min = Math.min, round = Math.round;\n  if(hex.length !== 7) { return hex; }\n  number = parseInt(hex.slice(1), 16);\n  R = number >> 16;\n  G = number >> 8 & 0xFF;\n  B = number & 0xFF;\n  red = min( 255, round( ( 1 + percent ) * R )).toString(16);\n  green = min( 255, round( ( 1 + percent ) * G )).toString(16);\n  blue = min( 255, round( ( 1 + percent ) * B )).toString(16);\n  return (\"#\" +  red +  green +  blue);\n\n};\n\n\n\n},{}]},{},[1])(1)\n});"],"file":"react-d3.js","sourceRoot":"/source/"}